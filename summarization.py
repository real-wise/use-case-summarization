# Databricks notebook source
# MAGIC %pip install openai

# COMMAND ----------

import os
import openai
import json
import re



#API Keys
os.environ['OPENAI_API_KEY'] = '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'


# COMMAND ----------

def strict_output(system_prompt, user_prompt, output_format, default_category = "", output_value_only = False,
                  model = 'gpt-3.5-turbo', temperature = 0, num_tries = 2, verbose = False):
    ''' Ensures that OpenAI will always adhere to the desired output json format. 
    Uses rule-based iterative feedback to ask GPT to self-correct.
    Keeps trying up to num_tries it it does not. Returns empty json if unable to after num_tries iterations.
    If output field is a list, will treat as a classification problem and output best classification category.
    Text enclosed within < > will generated by GPT accordingly'''

    # if the user input is in a list, we also process the output as a list of json
    list_input = isinstance(user_prompt, list)
    # if the output format contains dynamic elements of < or >, then add to the prompt to handle dynamic elements
    dynamic_elements = '<' in str(output_format)
    # if the output format contains list elements of [ or ], then we add to the prompt to handle lists
    list_output = '[' in str(output_format)
    
    # start off with no error message
    error_msg = ''
    
    for i in range(num_tries):
        
        output_format_prompt = f'''\nYou are to output the following in json format: {output_format}. 
Do not put quotation marks or escape character \ in the output fields.'''
        
        if list_output:
            output_format_prompt += f'''\nIf output field is a list, classify output into the best element of the list.'''
        
        # if output_format contains dynamic elements, process it accordingly
        if dynamic_elements: 
            output_format_prompt += f'''
Any text enclosed by < and > indicates you must generate content to replace it. Example input: Go to <location>, Example output: Go to the garden
Any output key containing < and > indicates you must generate the key name to replace it. Example input: {{'<location>': 'description of location'}}, Example output: {{school: a place for education}}'''

        # if input is in a list format, ask it to generate json in a list
        if list_input:
            output_format_prompt += '''\nGenerate a list of json, one json for each input element.'''
            
        # Use OpenAI to get a response
        openai.api_key = os.getenv("OPENAI_API_KEY")
        response = openai.ChatCompletion.create(
          temperature = temperature,
          model=model,
          messages=[
            {"role": "system", "content": system_prompt + output_format_prompt + error_msg},
            {"role": "user", "content": str(user_prompt)}
          ]
        )

        res = response['choices'][0]['message']['content'].replace('\'', '"')
        
        # ensure that we don't replace away aprostophes in text 
        res = re.sub(r"(\w)\"(\w)", r"\1'\2", res)

        if verbose:
            print('System prompt:', system_prompt + output_format_prompt + error_msg)
            print('\nUser prompt:', str(user_prompt))
            print('\nGPT response:', res)
        
        # try-catch block to ensure output format is adhered to
        try:
            output = json.loads(res)
            if isinstance(user_prompt, list):
                if not isinstance(output, list): raise Exception("Output format not in a list of json")
            else:
                output = [output]
                
            # check for each element in the output_list, the format is correctly adhered to
            for index in range(len(output)):
                for key in output_format.keys():
                    # unable to ensure accuracy of dynamic output header, so skip it
                    if '<' in key or '>' in key: continue
                    # if output field missing, raise an error
                    #if key not in output[index]: raise Exception(f"{key} not in json output")
                    # check that one of the choices given for the list of words is an unknown
                    if isinstance(output_format[key], list):
                        choices = output_format[key]
                        # ensure output is not a list
                        #if isinstance(output[index][key], list): can be one of the list elements
                            #output[index][key] = output[index][key][0]
                                                
                        # output the default category (if any) if GPT is unable to identify the category
                        #if output[index][key] not in choices and default_category:
                        if isinstance(output[index][key], list):
                            allowed_output = [x for x in output[index][key] if x in output_format[key]] # only elements in the given output format list is allowed
                                                        
                            # only when the allowed_output is not empty
                            if len(allowed_output)!= 0:
                                output[index][key] = allowed_output
                            else: # otherwise don't return this key,value pair
                                output[index].pop(key)
                                

                        # if the output is a description format, get only the label
                        #if ':' in output[index][key]:
                        #    output[index][key] = output[index][key].split(':')[0]
                            
                # if we just want the values for the outputs
                if output_value_only:
                    output[index] = [value for value in output[index].values()]
                    # just output without the list if there is only one element
                    if len(output[index]) == 1:
                        output[index] = output[index][0]
                    
            return output if list_input else output[0]

        except Exception as e:
            error_msg = f"\n\nResult: {res}\n\nError message: {str(e)}"
            print("An exception occurred:", str(e))
            print("Current invalid json format:", res)
         
    return {}

# COMMAND ----------

system_prompt = "You are a friendly assistant meant to summarise the text and extract information from text. If you donâ€™t know the information, don\'t assume and don\'t fill in the information."

# COMMAND ----------

example1 = ' Example text 1: I want to buy a house with a mountain view. near the supermarkets. not too far from the hospital. single storey. It locates in Ferntree Gully. price of 600k$ to 1000000$. Example output 1: {"summary": "mountain view. near the supermarkets. not too far from the hospital", "suburb_name": ["Ferntree Gully"], "property_type": ["House"], "budget_lower_bound": 600000, "budget_upper_bound": 1000000}'

# COMMAND ----------

example2 = ' Example text 2: looking for a townhouse or apartment with ocean view. near the seaside, in the following suburb: mornington, seaford, dromana. less than 10 minutes drive to shops. big mansion. 2-4 bedrooms, I have a budget between 1.5M and 3M. must have at least 3 car garages. Example output 2: {"summary": "ocean view. near the seaside. less than 10 minutes drive to shops. big mansion.", "suburb_name": ["Mornington", "Seaford", "Dromana"], "property_type": ["Townhouse", "Apartment"],"bedroom_lower_bound": 2, "bedroom_upper_bound": 4, "carpark_lower_bound": 3,  "budget_lower_bound": 1500000, "budget_upper_bound": 3000000}'

# COMMAND ----------

example3 = ' Example text 3: a place has modern design. 2 bedrooms. Example output 3: {"summary": "modern design.","bedroom_lower_bound": 2, "bedroom_upper_bound": 2}'

# COMMAND ----------

# chinese mum and dad want to send kids to good school and live in chinese suburb
#text = 'I want to buy a house in a good school zone. we need 3 bedrooms for kids and family.2 seperate bathrooms for kids and us. it needs to be 1.5 - 2M$.'

# city boy
#text = 'I want to buy a place near pakenham. modern design. close to park. 1-2 bedrooms, budget less than 1M$. garage can park at least 2 cars.'


#old man
#text = 'a giant house with country view, victorian style, not too far away from dandenong. at least 4 bedrooms and 2 bathrooms. i have a budget of more than 2.5M$'

text = "I want to buy in a place with strong rental income, nearby clayton, below 900k price, 3 bedroom, 2 bath, at least 1 car space, modern style, less than 5 year old"

# COMMAND ----------

# try
# need to force schema if possible.
res = strict_output(system_prompt = system_prompt+example1+example2+example3, 
              user_prompt = text,
              output_format = {"summary": "summary the text without all the numeric features",
                               "property_type": ['House','Townhouse','Apartment'],# to add more
                               "suburb_name": "a list. location information, must be an Australian suburb name",
                               "bathroom_lower_bound": "number of bathrooms minimum",
                               "bathroom_upper_bound": "number of bathrooms maximum",
                               "bedroom_lower_bound": "number of bedrooms minimum",
                               "bedroom_upper_bound": "number of bedrooms maximum",
                               "carpark_lower_bound": "number of car parks minimum",
                               "carpark_upper_bound": "number of car parks maximum",
                               "budget_lower_bound": "minimum budget. must be in integer format",
                               "budget_upper_bound": "maximum budget. must be in integer format"},
              default_category = ''
                   )
print(res)

# COMMAND ----------

def res_to_query(input_data):
    output = {}

    if 'property_type' in input_data:
        output["type"] = {"$in": input_data['property_type']}
        
    if 'suburb_name' in input_data:
        output["suburb_name"] = {"$in": [suburb_name.upper() for suburb_name in input_data['suburb_name']]}

    if 'bedroom_lower_bound' in input_data or 'bedroom_upper_bound' in input_data:
        bedroom_query = {}
        if 'bedroom_lower_bound' in input_data:
            bedroom_query["$gte"] = input_data['bedroom_lower_bound']
        if 'bedroom_upper_bound' in input_data:
            bedroom_query["$lte"] = input_data['bedroom_upper_bound']
        output["$and"] = output.get("$and", []) + [{"beds": bedroom_query}]

    if 'bathroom_lower_bound' in input_data or 'bathroom_upper_bound' in input_data:
        bathroom_query = {}
        if 'bathroom_lower_bound' in input_data:
            bathroom_query["$gte"] = input_data['bathroom_lower_bound']
        if 'bathroom_upper_bound' in input_data:
            bathroom_query["$lte"] = input_data['bathroom_upper_bound']
        output["$and"] = output.get("$and", []) + [{"baths": bathroom_query}]
        
    if 'carpark_lower_bound' in input_data or 'carpark_upper_bound' in input_data:
        carpark_query = {}
        if 'carpark_lower_bound' in input_data:
            carpark_query["$gte"] = input_data['carpark_lower_bound']
        if 'carpark_upper_bound' in input_data:
            carpark_query["$lte"] = input_data['carpark_upper_bound']
        output["$and"] = output.get("$and", []) + [{"cars": carpark_query}]

    if ('budget_lower_bound' in input_data) and ('budget_upper_bound' in input_data):
        #(low_esr < upper bound and high_esr > lower_bound) or (high_esr=0 and low_esr>lower_bound and low_esr<upper_bound)
        # allow 0 to include properties with only low_esr
   
        or_condition_1 = {"$and":[{"low_esr":{"$lte":input_data['budget_upper_bound']}},{"high_esr":{ "$gte":input_data['budget_lower_bound']}}]}
        or_condition_2 = {"$and":[{"high_esr":{"$eq":0}},{"low_esr":{"$gte":input_data['budget_lower_bound']}},{"low_esr":{"$lte":input_data['budget_upper_bound']}}]}
        output["$or"] = output.get("$or", []) + [or_condition_1,or_condition_2]
    
    if ('budget_lower_bound' in input_data) and ('budget_upper_bound' not in input_data):    
        #(high_esr == 0 and low_esr>budget_lower_bound) or (high_esr>budget_lower_bound)
        output["$or"] = output.get("$or", []) + [{"high_esr": {"$gte":input_data['budget_lower_bound']}},{"$and":[{"high_esr":{"$eq":0}},{"low_esr": {"$gte":input_data['budget_lower_bound']}}]}]
        
    if ('budget_lower_bound' not in input_data) and ('budget_upper_bound' in input_data):
        output["low_esr"] = {"$lte": input_data['budget_upper_bound']}

        
    #if 'budget_lower_bound' in input_data:
    #    output["high_esr"] = {'$or':[{'$gte': input_data['budget_lower_bound']},{'$eq': 0}]} # allow 0 to include properties with only low_esr

    #if 'budget_upper_bound' in input_data:
    #    output["low_esr"] = {"$lte": input_data['budget_upper_bound']}

        
    return (res['summary'],output)

# COMMAND ----------

user_query, user_filter = res_to_query(res)

# COMMAND ----------

user_query

# COMMAND ----------

user_filter
